#!/bin/sh -e

# Cache file which is stored in ~/.kube as a lot of kubectl things are
FILE_LOCATION=~/.kube/kcn_cache
# Error 1 - Unknown parameter supplied
E_OPTERROR_UNKNOWN="1"

COMMAND_LINE_OPTIONS_HELP="\nA script and kubectl plugin which makes it simply to ssh into nodes within your cluster.

This script heavily relies on your ssh _config to determine how the connections are made to the nodes which allows you
to easily connect to the nodes based on your unique networking configuration.

This is made simpler by available flags which will allow you to select what value is passed into the ssh command, i.e.
hostname/nodename, private-ip (as registered to k8s) or public-ip (obtained using AWS API calls).

Examples:
  kcn [options] <node>

Options:
  -l: An interactive method of selecting a node and how to ssh into it.
  -a: Will use the node name as the destination for ssh
  -i: Will use the nodes private IP within AWS
  -p: Will find and use the nodes public IP within AWS

Usage:
  kcn [flags] [options]"

function check_cache {
  echo $(grep "$1,$2" $FILE_LOCATION  2> /dev/null) | awk -F\, '{print $3}'
}
# TODO Update the caching mechanism
# BODY Something like the below but actually working. Also remove the lines in the other functions
# function check_cache {
#   data=$(grep "$1,$2" $FILE_LOCATION  2> /dev/null) | awk -F\, '{print $3}'
#   if [ "$data" != "" ] ; then
#     >&2 echo "Cache hit for $1"
#   else
#     >&2 echo "Cache miss for $1"
#   fi
#
#   echo "$data"
# }

function get_public_ip {
  response=$(check_cache "$1,public")
  if [ "$response" != "" ]; then
    >&2 echo "Cache hit for $1"
    echo $response
    return
  fi

  >&2 echo "Cache miss for $1"
  region=$(echo $1 | awk -F\. '{print $2}')
  ip=$(aws ec2 describe-network-interfaces --query NetworkInterfaces[].Association.PublicIp --output text --filter Name=private-dns-name,Values=$1 --region $region)
  printf "%s,%s,%s\n" $1 "public" $ip >> $FILE_LOCATION
  echo $ip
}

function get_private_ip {
  response=$(check_cache "$1,private")
  if [ "$response" != "" ]; then
    >&2 echo "Cache hit for $1"
    echo $response
    return
  fi

  >&2 echo "Cache miss for $1"
  ip=$(kubectl get no $1 --no-headers=true --output=custom-columns=IP:.status.addresses[0].address)
  printf "%s,%s,%s\n" $1 "private" $ip >> $FILE_LOCATION
  echo $ip
}

function list_nodes {
  IFS=$'\n'
  NODES=()
  count=0
  for i in $(kubectl get no --no-headers=true --output=custom-columns=NAME:.metadata.name); do
    printf "[$count] $i\n"
    NODES+=("$i")
    count=$(echo "$count+1" | bc)
  done
  read -p "Specify a number for a node to connect to: " node

  count=0
  for i in private-ip public-ip hostname; do
    printf "[$count] $i\n"
    count=$(echo "$count+1" | bc)
  done
  read -p "Which method of connecting: " method

  case $method in
    0) ssh $(get_private_ip ${NODES[$node]}) ;;
    1) ssh $(get_public_ip ${NODES[$node]}) ;;
    2) ssh ${NODES[$node]} ;;
    *) echo "Incorrect value specified." ;;
  esac
}

function help {
  echo "Usage: `basename $0` -h for help";
  echo "$COMMAND_LINE_OPTIONS_HELP"
}

# FIX This is likely just a tempoary workaround
function kubectl_plugin_decoder {
  if [ "$KUBECTL_PLUGINS_LOCAL_FLAG_PRIVATE_IP" != "" ] ; then
    ssh $(get_private_ip $KUBECTL_PLUGINS_LOCAL_FLAG_PRIVATE_IP)
  elif [ "$KUBECTL_PLUGINS_LOCAL_FLAG_PUBLIC_IP" != "" ] ; then
    ssh $(get_public_ip $KUBECTL_PLUGINS_LOCAL_FLAG_PUBLIC_IP)
  elif [ "$KUBECTL_PLUGINS_LOCAL_FLAG_NODENAME" != "" ] ; then
    ssh $KUBECTL_PLUGINS_LOCAL_FLAG_NODENAME
  elif [ "$KUBECTL_PLUGINS_LOCAL_FLAG_LIST" != "" ] ; then
    list_nodes
  else
    help
    exit $E_OPTERROR_UNKNOWN
  fi
}

if [ $(env | grep -c KUBECTL_PLUGINS_DESCRIPTOR_NAME) -eq 1 ] ; then
  kubectl_plugin_decoder
else
  getopts "a:i:p:hl" flag
  case $flag in
    i) ssh $(get_private_ip $OPTARG) ;;
    p) ssh $(get_public_ip $OPTARG) ;;
    a) ssh $OPTARG ;;
    l) list_nodes ;;
    h) help ;;
    \?) help; exit $E_OPTERROR_UNKNOWN ;;
  esac
fi
